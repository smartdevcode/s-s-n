# SPDX-FileCopyrightText: 2025 Rayleigh Research <to@rayleigh.re>
# SPDX-License-Identifier: MIT
import time
import traceback
import bittensor as bt
from ypyjson import YpyObject
from typing import Annotated, Optional, ClassVar, Literal
from taos.im.protocol.simulator import *
from taos.im.protocol.models import *
from taos.common.protocol import SimulationStateUpdate, EventNotification
from taos.im.protocol.events import *
from taos.im.protocol.models import Book, Account, Balance, Order
from taos.im.protocol.response import FinanceAgentResponse
from taos.im.utils.compress import compress, decompress

"""
The core intelligent market simulation protocol classes are defined here.
These are the classes which inherit from bittensor.synapse, and are the objects which are transmitted between validator and miner via dendrite query calls.
"""

FinanceNotice = Annotated[
    Union[SimulationStartEvent | LimitOrderPlacementEvent | MarketOrderPlacementEvent | OrderCancellationsEvent | ClosePositionsEvent | TradeEvent | ResetAgentsEvent | SimulationEndEvent],
    Field(discriminator="y")
]

class FinanceEventNotification(EventNotification):
    """
    Base class for intelligent market simulator event notifications.
    """
    @classmethod
    def from_json(self, json : dict):
        """
        Method to transform messages from simulator to synapse.
        """
        return FinanceEventNotification.model_construct(event=FinanceEvent.from_json(json))

class MarketSimulationStateUpdate(SimulationStateUpdate):
    """
    Main class for representing intelligent market simulator state.

    Attributes:
        version (int | None): Number indicating the version of the taos package which the validator sending the state update is running.
        timestamp (int): Simulation timestamp at which the state was recorded.
        config (MarketSimulationConfig | str | None): Details of the simulation configuration run by the sending validator.
        books (dict[int, Book] | None): Mapping from orderbook IDs to Book objects containing state information.
        accounts (dict[int, dict[int, Account]] | None): Mapping from agent IDs to dictionaries associating orderbook IDs with agent account states.
        notices (dict[int, list[SimulationStartEvent | LimitOrderPlacementEvent | MarketOrderPlacementEvent | OrderCancellationsEvent | ClosePositionsEvent | TradeEvent | ResetAgentsEvent | SimulationEndEvent]] | None):
            Mapping from agent IDs to lists of market events relevant to them since the last state update.
        response (Optional[FinanceAgentResponse] | None): Mutable field to be populated by the miner agent with instructions to execute.
        compressed (str | dict | None): Compressed format of the state data to reduce message size during transmission.
        compression_engine (str): Compression library used by the validator; one of `zlib` or `lz4`  or `zstd` (default is `lz4`).
    """
    version : int | None = None
    timestamp : int
    config : MarketSimulationConfig | str | None = None
    books : dict[int,Book] | None = None
    accounts : dict[int,dict[int, Account]] | None = None
    notices : dict[int, list[FinanceNotice]] | None = None
    response: Optional[FinanceAgentResponse] | None  = None
    compressed : str | dict | None = None
    compression_engine : str = "lz4"

    required_fields: ClassVar[list[str]] = None
    def get_required_fields(self) -> list[str]:
        """
        Get the required fields from the model's JSON schema.
        """
        if not self.required_fields:
            schema = self.__class__.model_json_schema()
            MarketSimulationStateUpdate.required_fields = schema.get("required", [])
        return self.required_fields

    def environment_state(self) -> dict[int, Book]:
        """
        Method returning the state of the simulation environment; in the case of intelligent markets simulation, this is the orderbook state dictionary.
        """
        return self.books

    def agent_state(self) -> dict[int, dict[int, Account]]:
        """
        Method returning the state of the simulation agents; in the case of intelligent markets simulation, this is the accounts dictionary.
        """
        return self.accounts

    @classmethod
    def from_simulator(cls, json : dict):
        """
        WIP: Method to efficiently transform state update message generated by simulator to subnet synapse format.
        """
        start = time.time()
        books = {book_id : Book.from_json(book) for book_id, book in json['books'].items()}
        bt.logging.debug(f"Books populated ({time.time()-start:.4f}s).")
        start = time.time()
        accounts = {uid : {agentId : Account.from_json(account) for agentId, account in uid_accounts.items()} for uid, uid_accounts in json['accounts'].items()}
        bt.logging.debug(f"Accounts populated ({time.time()-start:.4f}s).")
        start = time.time()
        notices = {int(uid) : [FinanceEvent.from_json(notice) for notice in uid_notices] for uid, uid_notices in json['notices'].items() if int(uid) >= 0}
        bt.logging.debug(f"Notices populated ({time.time()-start:.4f}s).")
        return MarketSimulationStateUpdate(timestamp=json['timestamp'],model="im",books=books,accounts=accounts,notices=notices)

    @classmethod
    def from_json(cls, json : dict):
        """
        Method to transform state update message generated by simulator to subnet synapse format.
        """
        start = time.time()
        payload = json['payload']
        model = 'im'
        books = {book['bookId'] : Book.from_json(book) for book in payload['books']}
        bt.logging.debug(f"Books populated ({time.time()-start:.4f}s).")
        start = time.time()
        accounts = {}
        for sagentId, account in payload['accounts'].items():
            agentId = int(sagentId)
            if agentId >= 0:
                for book_id, balances in enumerate(account['holdings']):
                    if not agentId in accounts:
                        accounts[agentId] = {}
                    accounts[agentId][book_id] = Account(
                        agent_id=account['agentId'],book_id=book_id,
                        base_balance=Balance.from_json(currency='BASE', json=balances['base']),
                        quote_balance=Balance.from_json(currency='QUOTE', json=balances['quote']),
                        orders=[Order.from_json(order) for order in account['orders'][book_id]] if account['orders'] and account['orders'][book_id] else [],
                        loans={int(id) : Loan.from_json(loan) for id, loan in account['loans'][book_id].items()} if account['loans'] and account['loans'][book_id] else {},
                        fees=Fees.from_json(account['fees'][str(book_id)]) if account['fees'] else None
                    )
        bt.logging.debug(f"Accounts populated ({time.time()-start:.4f}s).")
        start = time.time()
        notices = {int(uid) : [] for uid in payload['accounts'] if int(uid) >= 0}
        for notice in sorted(payload['notices'], key=lambda x: (x['timestamp'], -x['delay'])):
            notice = FinanceEventNotification.from_json(notice)
            if notice.event.agentId:
                notices[notice.event.agentId].append(notice.event)
            else:
                for uid in [int(agentId) for agentId in payload['accounts'] if int(agentId) >= 0]:
                    notices[uid].append(notice.event)
        notices = {agentId : sorted(agent_notices, key=lambda x: x.timestamp) for agentId, agent_notices in notices.items()}
        bt.logging.debug(f"Notices populated ({time.time()-start:.4f}s).")
        return MarketSimulationStateUpdate(timestamp=json['timestamp'],model=model,books=books,accounts=accounts,notices=notices)

    @classmethod
    def from_ypy(cls, json: YpyObject):
        """
        Transform state update message generated by simulator into subnet synapse format.
        YpyObject-safe (no .get() or **kwargs from Ypy), optimized to avoid redundant work.
        """
        start = time.time()
        payload = json['payload']
        model = 'im'

        books = {book['bookId'] : Book.from_ypy(book) for book in payload['books']}
        bt.logging.info(f"Books populated ({time.time() - start:.4f}s).")

        start = time.time()
        accounts = {}
        for sagentId, account in payload['accounts']:
            agent_id = int(sagentId)
            if agent_id < 0:
                continue

            holdings = account['holdings']
            orders_data = account['orders']
            loans_data  = account['loans']
            fees_data   = account['fees']

            agent_accounts = accounts.setdefault(agent_id, {})

            for book_id, balances in enumerate(holdings):
                base_balance = Balance.from_json(currency='BASE', json=balances['base'])
                quote_balance = Balance.from_json(currency='QUOTE', json=balances['quote'])

                book_orders = []
                if orders_data and book_id < len(orders_data) and orders_data[book_id]:
                    book_orders = [Order.from_json(o) for o in orders_data[book_id]]

                book_loans = {}
                if loans_data and book_id < len(loans_data) and loans_data[book_id]:
                    book_loans = {int(i): Loan.from_json(l) for i, l in loans_data[book_id]}

                book_fees = Fees.from_json(fees_data[str(book_id)])

                agent_accounts[book_id] = Account.model_construct(
                    agent_id=account['agentId'],
                    book_id=book_id,
                    base_balance=base_balance,
                    quote_balance=quote_balance,
                    base_loan=balances['baseLoan'],
                    quote_loan=balances['quoteLoan'],
                    base_collateral=balances['baseCollateral'],
                    quote_collateral=balances['quoteCollateral'],
                    orders=book_orders,
                    loans=book_loans,
                    fees=book_fees
                )
        bt.logging.info(f"Accounts populated ({time.time() - start:.4f}s).")

        start = time.time()
        valid_agents = [int(uid) for uid, _ in payload['accounts'] if int(uid) >= 0]
        notices = {agent_id: [] for agent_id in valid_agents}

        for raw_notice in sorted(payload['notices'], key=lambda x: (x['timestamp'], -x['delay'])):
            n = FinanceEventNotification.from_json(raw_notice)
            target_id = n.event.agentId

            if target_id:
                if target_id in notices:
                    notices[target_id].append(n.event)
            else:
                for agent_id in valid_agents:
                    notices[agent_id].append(n.event)

        for agent_id in notices:
            notices[agent_id].sort(key=lambda e: e.timestamp)

        bt.logging.info(f"Notices populated ({time.time() - start:.4f}s).")

        return MarketSimulationStateUpdate(
            timestamp=json['timestamp'],
            model=model,
            books=books,
            accounts=accounts,
            notices=notices
        )

    def clear_inputs(self):
        """
        Method to empty state input data fields to prevent unnecessary data transfer from miners.
        """
        self.books = None
        self.accounts = None
        self.notices = None
        self.config = None
        return self

    def compress(self, level=-1, engine : Literal["zlib", "lz4", "zstd"] | None = None, compressed_books : str = None):
        """
        Method to compress large synapse fields for transmission over the network.

        Note this method DOES NOT modify the synapse in place, so that the original synapse data can be referenced after sending without requiring decompression.
        """
        try:
            if engine:
                self.compression_engine = engine
            if not self.compressed:
                if self.response:
                    agent_id = self.response.agent_id
                compressed = self.model_copy()
                if not compressed_books:
                    compressed_books = compress({bookId : book.model_dump(mode='json') if isinstance(book, Book) else book for bookId, book in compressed.books.items()} if compressed.books else None, level, compressed.compression_engine, self.version)
                payload = {
                    "accounts" : {accountId : {bookId : account.model_dump(mode='json') if isinstance(account, Account) else account for bookId, account in accounts.items()} for accountId, accounts in compressed.accounts.items()} if compressed.accounts else None,
                    "notices" : {agentId : [notice if isinstance(notice, dict) else notice.model_dump(mode='json') for notice in notices] for agentId, notices in compressed.notices.items()} if compressed.notices else None,
                    "config" : compressed.config.model_dump(mode='json') if compressed.config else None,
                    "response" : compressed.response.model_dump(mode='json') if compressed.response else None
                }
                compressed.compressed = {
                    "books" : compressed_books,
                    "payload" : compress(payload, level, compressed.compression_engine, self.version)
                }
                compressed.books = None
                compressed.accounts = None
                compressed.notices = None
                compressed.config = None
                compressed.response = None if self.version or not self.response else FinanceAgentResponse(agent_id=agent_id)
                return compressed
            else:
                return self
        except Exception as ex:
            bt.logging.error(f"Failed to compress {self.name} synapse data! {ex}")
            return None
        
    @classmethod
    def parse_dict(cls, data):
        start = time.time()
        ret = MarketSimulationStateUpdate(timestamp=data['timestamp'])
        object.__setattr__(ret, "books", data.get("books", {}))
        object.__setattr__(ret, "accounts", data.get("accounts", {}))
        object.__setattr__(ret, "accounts", data.get("accounts", {}))
        object.__setattr__(ret, "notices", data.get("notices", {}))        
        bt.logging.info(f"Parsed state dict ({time.time() - start:.4f}s)")
        return ret

    def decompress(self, lazy=False):
        """
        Method to decompress large synapse fields after transmission over the network.

        Note this method DOES modify the synapse in place, so that the synapse can be used normally after decompression.
        """
        try:
            if not self.compressed:
                return self

            start = time.time()
            decompressed = decompress(self.compressed, self.compression_engine, self.version)
            bt.logging.debug(f"Decompressed state update ({time.time() - start:.4f}s)")
            self.compressed = None

            if not lazy:
                sstart = time.time()
                self.books = decompressed['books']
                bt.logging.debug(f"Populated books ({time.time() - sstart:.4f}s)")

                sstart = time.time()
                self.accounts = decompressed['accounts']
                bt.logging.debug(f"Populated accounts ({time.time() - sstart:.4f}s)")
            else:
                sstart = time.time()
                object.__setattr__(self, "books", LazyBooks(decompressed.get("books", {})))
                bt.logging.debug(f"Prepared books [Lazy] ({time.time() - sstart:.4f}s)")

                sstart = time.time()
                object.__setattr__(
                    self,
                    "accounts",
                    LazyAccounts(decompressed.get("accounts", {}))
                )
                bt.logging.debug(f"Prepared accounts [Lazy] ({time.time() - sstart:.4f}s)")

            sstart = time.time()
            self.notices = decompressed['notices']
            bt.logging.debug(f"Populated notices ({time.time() - sstart:.4f}s)")

            sstart = time.time()
            self.config = decompressed['config']
            bt.logging.debug(f"Populated config ({time.time() - sstart:.4f}s)")

            sstart = time.time()
            self.response = decompressed['response']
            bt.logging.debug(f"Populated response ({time.time() - sstart:.4f}s)")

            bt.logging.debug(f"Parsed state update ({time.time() - start:.4f}s)")
            return self
        except Exception as ex:
            bt.logging.error(f"Failed to decompress {self.name} synapse data! {ex}\n{traceback.format_exc()}")
            return None
